#include <pch.hpp>
#include <xrn/Engine/Component/Velocity.hpp>
#include <xrn/Engine/Component/Control.hpp>



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Constructors
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
::xrn::engine::component::Velocity::Velocity()
    : m_velocity{ 0.0f }
{}

///////////////////////////////////////////////////////////////////////////
::xrn::engine::component::Velocity::Velocity(
    const float velocity
)
    : m_velocity{ velocity }
{}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Update
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////
auto ::xrn::engine::component::Velocity::update(
    ::xrn::Time deltaTime
    , const ::xrn::engine::component::Control& control
) -> Velocity&
{
    // search the number of directions moving in and removing speed when multiple direction at once
    auto speedDirectionDivider{ 2.0f };

    // bot top
    if (control.isAbleToFly()) {
        if (control.isMovingUp()) {
            if (!control.isMovingDown()) {
                speedDirectionDivider /= 1.5f;
            }
        } else if (control.isMovingDown()) {
            speedDirectionDivider /= 1.5f;
        }
    }

    // left right
    if (control.isMovingLeft()) {
        if (!control.isMovingRight()) {
            speedDirectionDivider /= 1.5f;
        }
    } else if (control.isMovingRight()) {
        speedDirectionDivider /= 1.5f;
    }

    // forward backward
    if (speedDirectionDivider > 1.0f) {
        if (control.isMovingForward()) {
            if (!control.isMovingBackward()) {
                speedDirectionDivider /= 1.5f;
            }
        } else if (control.isMovingBackward()) {
            speedDirectionDivider /= 1.5f;
        } else if (speedDirectionDivider == 2.0f) {
            return *this; // not any direction
        }
    }

    // apply movement
    m_velocity =  control.getSpeed() * deltaTime * speedDirectionDivider / 100'000;
    return *this;
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Setters getters
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
auto ::xrn::engine::component::Velocity::set(
    const float velocity
) -> Velocity&
{
    m_velocity = velocity;
    return *this;
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::engine::component::Velocity::get() const
    -> float
{
    return m_velocity;
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::engine::component::Velocity::get()
    -> float&
{
    return m_velocity;
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Comparisons
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
auto ::xrn::engine::component::Velocity::operator<=>(
    float other
) const
    -> ::std::partial_ordering
{
    return this->m_velocity <=> other;
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::engine::component::Velocity::operator<=>(
    const Velocity& other
) const
    -> ::std::partial_ordering
{
    return this->m_velocity <=> other.m_velocity;
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::engine::component::Velocity::operator=(
    float velocity
) -> Velocity&
{
    this->set(velocity);
    return *this;
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::engine::component::Velocity::operator+(
    float velocity
) -> float
{
    return m_velocity + velocity;
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::engine::component::Velocity::operator+=(
    float velocity
) -> Velocity&
{
    m_velocity += velocity;
    return *this;
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::engine::component::Velocity::operator-(
    float velocity
) -> float
{
    return m_velocity - velocity;
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::engine::component::Velocity::operator-=(
    float velocity
) -> Velocity&
{
    m_velocity -= velocity;
    return *this;
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::engine::component::Velocity::operator*(
    float velocity
) -> float
{
    return m_velocity * velocity;
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::engine::component::Velocity::operator*=(
    float velocity
) -> Velocity&
{
    m_velocity *= velocity;
    return *this;
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::engine::component::Velocity::operator/(
    float velocity
) -> float
{
    return m_velocity / velocity;
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::engine::component::Velocity::operator/=(
    float velocity
) -> Velocity&
{
    m_velocity /= velocity;
    return *this;
}

///////////////////////////////////////////////////////////////////////////
::xrn::engine::component::Velocity::operator float() const
{
    return m_velocity;
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::engine::component::Velocity::operator*()
    -> float&
{
    return m_velocity;
}
