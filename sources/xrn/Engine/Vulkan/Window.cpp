///////////////////////////////////////////////////////////////////////////
// Precompilled headers
///////////////////////////////////////////////////////////////////////////
#include <pch.hpp>

///////////////////////////////////////////////////////////////////////////
// Headers
///////////////////////////////////////////////////////////////////////////
#include <xrn/Engine/Vulkan/Window.hpp>
#include <xrn/Engine/Event/WindowResized.hpp>
#include <xrn/Engine/Event/KeyPressed.hpp>
#include <xrn/Engine/Event/KeyReleased.hpp>
#include <xrn/Engine/Event/MouseMoved.hpp>

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// static elements
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
auto ::xrn::engine::vulkan::Window::Size::isValid()
    -> bool
{
    return !(!this->width || !this->height);
}

///////////////////////////////////////////////////////////////////////////
::xrn::engine::vulkan::Window::Size::operator VkExtent2D() const
{
    return { .width = static_cast<::std::uint32_t>(width), .height = static_cast<::std::uint32_t>(height) };
}


///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Constructors
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
::xrn::engine::vulkan::Window::Window(
    bool isFullscreen, /* = true */
    const ::std::string& windowName /* = Window::defaultName */
)
    : m_size{ Window::defaultSize }
    , m_window{ ::glfwCreateWindow(
        static_cast<int>(m_size.width)
        , static_cast<int>(m_size.height)
        , windowName.c_str()
        , isFullscreen ? ::glfwGetPrimaryMonitor() : nullptr
        , nullptr
    ) }
{
    XRN_ASSERT(!!m_window, "Create glfw window");

    ::glfwSetWindowUserPointer(m_window.get(), &m_events);
    this->hideCursor();

    // setup callbacks
    ::glfwSetFramebufferSizeCallback(m_window.get(), Window::framebufferResizeCallback);
    ::glfwSetKeyCallback(m_window.get(), Window::keyCallback);
    ::glfwSetCursorPosCallback(m_window.get(), Window::mouseMovedCallback);

    // ::glfwSetScrollCallback(m_window.get(), Window::mouseScrollcallback);
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Rule of 5
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
::xrn::engine::vulkan::Window::~Window() = default;

///////////////////////////////////////////////////////////////////////////
::xrn::engine::vulkan::Window::Window(
    Window&&
) noexcept = default;

///////////////////////////////////////////////////////////////////////////
auto ::xrn::engine::vulkan::Window::operator=(
    Window&&
) noexcept
    -> Window& = default;



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Basic operations
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
auto ::xrn::engine::vulkan::Window::shouldClose() const
    -> bool
{
    return ::glfwWindowShouldClose(m_window.get()) || m_shouldClose;
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::engine::vulkan::Window::clear() const
{
    // ::glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::engine::vulkan::Window::close()
{
    ::glfwSetWindowShouldClose(m_window.get(), GLFW_TRUE);
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::engine::vulkan::Window::display() const
{
    // ::glfwSwapBuffers(m_window.get());
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::engine::vulkan::Window::handleEvents(
    ::xrn::engine::AScene& scene
)
{
    ::glfwPollEvents();
    m_events.resolve(scene);
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::engine::vulkan::Window::wasResized()
    -> bool
{
    return m_framebufferResized;
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::engine::vulkan::Window::resetResizedFlag()
{
    m_framebufferResized = false;
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::engine::vulkan::Window::setResizedFlag()
{
    m_framebufferResized = true;
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::engine::vulkan::Window::resize(
    const Window::Size& size
)
{
    m_size.width = size.width;
    m_size.height = size.height;
    this->setResizedFlag();
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::engine::vulkan::Window::hideCursor(
    bool shouldHide // = true
)
{
    if (shouldHide) {
        ::glfwSetCursorPos(
            m_window.get()
            , static_cast<double>(m_size.width) / 2
            , static_cast<double>(m_size.height) / 2
        );
        ::glfwSetInputMode(m_window.get(), GLFW_CURSOR, GLFW_CURSOR_HIDDEN);
        m_isCursorHidden = true;
    } else {
        ::glfwSetInputMode(m_window.get(), GLFW_CURSOR, GLFW_CURSOR_NORMAL);
        m_isCursorHidden = false;
    }
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Other
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
auto ::xrn::engine::vulkan::Window::getSize() const
    -> const Window::Size&
{
    return m_size;
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::engine::vulkan::Window::getCursorPosition() const
    -> ::glm::vec2
{
    double xpos, ypos;
    ::glfwGetCursorPos(m_window.get(), &xpos, &ypos);
    return ::glm::vec2{ static_cast<float>(xpos), static_cast<float>(ypos) };
}

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Vulkan implementation
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
void ::xrn::engine::vulkan::Window::createWindowSurface(
    ::VkInstance instance
    , ::VkSurfaceKHR* surface
)
{
    XRN_ASSERT(
        ::glfwCreateWindowSurface(instance, m_window.get(), nullptr, surface) == VK_SUCCESS
        , "Create glfw window surface"
    );
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// GLFW callbacks
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
void ::xrn::engine::vulkan::Window::framebufferResizeCallback(
    ::GLFWwindow* window
    , const int width
    , const int height
) {
    auto& events{ *reinterpret_cast<::xrn::engine::event::Container*>(::glfwGetWindowUserPointer(window)) };
    events.emplace<::xrn::engine::event::WindowResized>(Window::Size{
        .width = static_cast<::std::size_t>(width)
        , .height = static_cast<::std::size_t>(height)
    });
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::engine::vulkan::Window::keyCallback(
    GLFWwindow* window
    , const int keyCode
    , const int scancode [[ maybe_unused ]]
    , const int action
    , const int mods [[ maybe_unused ]]
)
{
    auto& events{ *reinterpret_cast<::xrn::engine::event::Container*>(::glfwGetWindowUserPointer(window)) };
    if (action == GLFW_PRESS) {
        events.emplace<::xrn::engine::event::KeyPressed>(keyCode);
    } else if (action == GLFW_RELEASE) {
        events.emplace<::xrn::engine::event::KeyReleased>(keyCode);
    }
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::engine::vulkan::Window::mouseMovedCallback(
    GLFWwindow* window
    , const double xPos
    , const double yPos
)
{
    auto& events{ *reinterpret_cast<::xrn::engine::event::Container*>(::glfwGetWindowUserPointer(window)) };
    int width, height;
    ::glfwGetWindowSize(window, &width, &height);
    events.emplace<::xrn::engine::event::MouseMoved>(xPos - width / 2, yPos - height / 2);
}

void ::xrn::engine::vulkan::Window::mouseScrollcallback(
    GLFWwindow* window [[ maybe_unused ]]
    , const double xOffset [[ maybe_unused ]]
    , const double yOffset [[ maybe_unused ]]
)
{}





///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// GLFW memory
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
void ::xrn::engine::vulkan::Window::Deleter::operator()(
    ::GLFWwindow* window
)
{
    ::glfwDestroyWindow(window);
}

///////////////////////////////////////////////////////////////////////////
class GlfwMemoryManager {
    GlfwMemoryManager()
    {
        XRN_ASSERT(::glfwInit(), "Init glfw");
        ::glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
        ::glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE);
        // stbi_set_flip_vertically_on_load(true);
    }

    ~GlfwMemoryManager()
    {
        ::glfwTerminate();
    }

    static const GlfwMemoryManager _;
};
const ::GlfwMemoryManager GlfwMemoryManager::_;
