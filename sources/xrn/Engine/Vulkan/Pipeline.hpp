#pragma once

namespace xrn::engine::vulkan { class Window; }
namespace xrn::engine::vulkan { class Device; }

namespace xrn::engine::vulkan {

///////////////////////////////////////////////////////////////////////////
/// \brief Pipeline wrapper for GLFW
/// \ingroup vulkan
///
/// \include Pipeline.hpp <Pipeline.hpp>
///
///////////////////////////////////////////////////////////////////////////
class Pipeline {

public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // static elements
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Contains the size of the window
    ///
    ///////////////////////////////////////////////////////////////////////////
    struct Configuration {
        Configuration();
        Configuration(
            const ::xrn::engine::vulkan::Pipeline::Configuration&
        ) = delete;
        ::xrn::engine::vulkan::Pipeline::Configuration& operator=(
            const ::xrn::engine::vulkan::Pipeline::Configuration&
        ) = delete;
        void enableAlphaBlending();

        ::std::vector<::VkVertexInputBindingDescription> bindingDescriptions{};
        ::std::vector<::VkVertexInputAttributeDescription> attributeDescriptions{};
        ::VkPipelineViewportStateCreateInfo viewportInfo{};
        ::VkPipelineInputAssemblyStateCreateInfo inputAssemblyInfo{};
        ::VkPipelineRasterizationStateCreateInfo rasterizationInfo{};
        ::VkPipelineMultisampleStateCreateInfo multisampleInfo{};
        ::VkPipelineColorBlendAttachmentState colorBlendAttachment{};
        ::VkPipelineColorBlendStateCreateInfo colorBlendInfo{};
        ::VkPipelineDepthStencilStateCreateInfo depthStencilInfo{};
        ::std::vector<::VkDynamicState> dynamicStateEnables{};
        ::VkPipelineDynamicStateCreateInfo dynamicStateInfo{};
        ::VkPipelineLayout pipelineLayout{ nullptr };
        ::VkRenderPass renderPass{ nullptr };
        ::std::uint32_t subpass{ 0 };
    };



public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Constructors
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Default constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    explicit Pipeline(
        ::xrn::engine::vulkan::Device& device
        , const Pipeline::Configuration& configuration
        , ::std::string_view shaderFilenames
    );



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Rule of 5
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Destructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    ~Pipeline();

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Copy constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    Pipeline(
        const Pipeline&
    ) noexcept = delete;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Copy assign operator
    ///
    ///////////////////////////////////////////////////////////////////////////
    auto operator=(
        const Pipeline&
    ) noexcept
        -> Pipeline& = delete;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Move constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    Pipeline(
        Pipeline&&
    ) noexcept = delete;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Move assign operator
    ///
    ///////////////////////////////////////////////////////////////////////////
    auto operator=(
        Pipeline&&
    ) noexcept
        -> Pipeline& = delete;



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Vulkan stuff
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    void bind(
        ::VkCommandBuffer commandBuffer
    );



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Getters
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the vulkan device
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getDevice()
        -> ::xrn::engine::vulkan::Device&;



private:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Helpers
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief TODO
    ///
    /// Puts the content of the file in a vector of char.
    ///
    /// TODO: What is a shader module
    ///
    ///////////////////////////////////////////////////////////////////////////
    void createShaderModule(
        const ::std::string& filepath
        , ::VkShaderModule& shaderModule
    );



private:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Member variables
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ::xrn::engine::vulkan::Device& m_device;
    ::VkPipeline m_graphicsPipeline;

    ::VkShaderModule m_vertexShaderModule;
    ::VkShaderModule m_fragmentShaderModule;

};

} // namespace xrn::engine::vulkan
